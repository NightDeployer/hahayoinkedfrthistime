<!DOCTYPE html>
<html>
  <head>
    <title>online game:remastered</title>
    <style>
      /* Give the page a clean, modern look */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: Arial, sans-serif;
      }
      html, body {
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      body {
        background: linear-gradient(120deg, #e0e0e0, #ffffff);
        cursor: default;
      }

      /* MAIN GAME WRAPPER */
      #main {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      /* PLAYER */
      #player {
        height: 50px;
        width: 50px;
        background-color: blue;
        position: absolute;
        border-radius: 6px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        transform: translate(-50%, -50%);
      }

      /* The corrected class for other players */
      .otherPlayer {
        transition: 0.05s linear;
        height: 50px;
        width: 50px;
        background-color: red; /* or any default color */
        position: absolute;
        border-radius: 6px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        transform: translate(-50%, -50%);
      }

      /* CHAT */
      #chatArea {
        z-index: 1000;
        position: absolute;
        right: 20px;
        bottom: 80px; 
        width: 300px;
        max-height: 320px;
        background-color: rgba(40, 40, 40, 0.8);
        color: #eee;
        border-radius: 8px;
        padding: 10px;
        overflow-y: auto;
      }
      #chatArea::-webkit-scrollbar {
        width: 6px;
      }
      #chatArea::-webkit-scrollbar-thumb {
        background-color: #666;
        border-radius: 8px;
      }

      #messageInput {
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 300px;
        box-sizing: border-box;
        padding: 8px;
        border: 2px solid #ccc;
        border-radius: 6px;
        outline: none;
        font-size: 14px;
      }
      #messageInput:focus {
        border-color: #66aaff;
      }

      /* INVENTORY SIDEPANEL (Tab) */
      #invMain {
        z-index: 1000;
        padding: 10px;
        width: 320px;
        height: 70%;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        position: absolute;
        background-color: rgba(40, 40, 40, 0.9);
        display: none;
        border-radius: 8px;
        overflow-y: auto;
      }
      #invMain h1 {
        color: #fff;
        margin-bottom: 10px;
        text-align: center;
      }
      #invMain::-webkit-scrollbar {
        width: 6px;
      }
      #invMain::-webkit-scrollbar-thumb {
        background-color: #666;
        border-radius: 8px;
      }

      /* QUICK SLOTS */
      #slots {
        position: absolute;
        bottom: 10px;
        width: 400px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        justify-content: space-around;
        z-index: 1000;
      }
      .slot {
        font-size: 13px;
        font-weight: bold;
        height: 60px;
        width: 60px;
        background-color: rgb(187, 185, 185);
        margin: 5px;
        border-radius: 6px;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        box-shadow: inset 0 0 5px rgba(0,0,0,0.15);
      }
      .slot:hover {
        background-color: #aaa;
        cursor: pointer;
      }

      /* ONLINE TEXT, COORDS, OBJECT TEXT */
      #online-text {
        position: absolute;
        top: 20px;
        left: 20px;
        color: #333;
        font-weight: bold;
      }
      #cords {
        position: absolute;
        top: 46px;
        left: 20px;
        color: #333;
      }
      #object-text {
        position: absolute;
        top: 72px;
        left: 20px;
        color: #333;
      }

      /* USERNAME POPUP */
      #usernamePopup {
        position: absolute;
        width: 100%;
        height: 100%;
        backdrop-filter: blur(4px);
        background-color: rgba(0,0,0,0.3);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      #usernamePopup h1 {
        margin: 10px 0;
        color: #222;
      }
      #usernamePopup p {
        color: #444;
      }
      #errorText {
        color: red;
      }

      #usernameInput {
        margin-bottom: 10px;
        padding: 10px;
        width: 250px;
        border: 2px solid #ccc;
        border-radius: 6px;
        outline: none;
        font-size: 16px;
        text-align: center;
      }
      #usernameInput:focus {
        border-color: #66aaff;
      }

      #usernameButton {
        transition: 0.3s ease;
        border: 2px solid #28a745;
        background-color: #fafafa;
        padding: 10px 20px;
        font-size: 18px;
        border-radius: 12px;
        cursor: pointer;
      }
      #usernameButton:hover {
        background-color: #28a745;
        color: #fff;
      }

      /* PLAYER MESSAGES INSIDE CHAT */
      #playerMessage {
        margin: 5px 0;
        word-break: break-word;
      }

      /* "BLOCKS" AND "TERRAIN" */
      #wall {
        height: 100px;
        width: 100px;
        background-color: rgb(165, 91, 42);
        position: absolute;
      }
      .block {
        position: absolute;
        z-index: -1000;
      }
      .terrain {
        z-index: -100;
        background-color: #3dad49;
        position: absolute;
        border-radius: 8px;
      }

      /* HOVER ELEMENT FOR PLACING BLOCKS */
      #hover {
        transition: transform 0.1s linear;
        position: absolute;
        background-color: rgba(83, 83, 83, 0.5);
        display: none; /* Hidden by default until 'Create' slot is chosen */
        border: 1px dashed #999;
      }
      #hoverText {
        position: absolute;
        left: -40px;
        top: 50px; 
        width: 200px;
        color: #444;
      }
      #blockSelector {
        z-index: 1000;
        display: none;
        overflow: auto;
        left: -120px;
        top: 80px;
        position: absolute;
        height: 200px;
        width: 300px;
        background-color: rgba(125, 125, 125, 0.6);
        border-radius: 6px;
        padding: 10px;
      }
      #sSquare, #sRect, #sCircle, #sSign {
        display: inline-block;
        margin: 10px;
        cursor: pointer;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      }
      #sSquare {
        height: 50px;
        width: 50px;
        background-color: blue;
      }
      #sRect {
        height: 50px;
        width: 25px;
        background-color: white;
      }
      #sCircle {
        height: 50px;
        width: 50px;
        background-color: white;
        border-radius: 50%;
      }
      #sSign {
        height: 50px;
        width: 50px;
        background-color: white;
      }
      #signText {
        position: absolute;
        top: 6px;
        left: 215px;
      }

      /* HEALTH BAR */
      #healthBarBack {
        position: absolute;
        z-index: 100;
        background-color: #b3b3b3;
        border: 2px solid #333;
        width: 200px;
        height: 14px;
        border-radius: 7px;
        bottom: 85px; 
        left: 50%;
        transform: translateX(-50%);
      }
      #healthBar {
        position: absolute;
        height: 100%;
        width: 100px;
        background-color: rgb(255, 0, 0);
        border-radius: 7px;
      }

      /* SWORD & BOW */
      #sword {
        transition: 0.2s linear;
        top: -30px;
        left: 45px;
        height: 75px;
        width: 10px;
        background-color: rgb(0, 0, 0);
        position: absolute;
        transform-origin: bottom;
        transform: rotate(90deg);
        border-radius: 3px;
      }
      #bow {
        transition: 0.1s linear;
        top: -30px;
        left: 40px;
        height: 70px;
        width: 5px;
        background-color: brown;
        position: absolute;
        transform-origin: center;
        transform: rotate(90deg);
        display: none;
        border-radius: 2px;
      }

      /* COLOR PICKER */
      #colorPicker {
        position: absolute;
        width: 200px;
        height: 200px;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-wrap: wrap;
        z-index: 2000;
        box-shadow: 0 0 15px rgba(0,0,0,0.2);
        background-color: rgba(240, 240, 240, 0.9);
        display: none;
      }
      .color-section {
        position: absolute;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        cursor: pointer;
        transition: transform 0.5s ease, opacity 0.5s ease;
        transform: translate(0, 0);
        opacity: 1;
        border: 2px solid #fff;
      }
      .color-section:nth-child(1) { --dx: 75px; --dy: -75px; }
      .color-section:nth-child(2) { --dx: 100px; --dy: 0; }
      .color-section:nth-child(3) { --dx: 75px; --dy: 75px; }
      .color-section:nth-child(4) { --dx: 0; --dy: 100px; }
      .color-section:nth-child(5) { --dx: -75px; --dy: 75px; }
      .color-section:nth-child(6) { --dx: -100px; --dy: 0; }
      .color-section:nth-child(7) { --dx: -75px; --dy: -75px; }
      .color-section:nth-child(8) { --dx: 0; --dy: -100px; }

      /* INVENTORY (press 'e') */
      #inventory {
        z-index: 10000;
        left: 50%;
        top: 50%;
        position: absolute;
        transform: translate(-50%, -50%);
        width: 450px;
        height: 300px;
        background-color: rgba(30, 30, 30, 0.9);
        color: #fafafa;
        border-radius: 10px;
        text-align: center;
        display: none;
      }
      #inventory h1 {
        margin: 20px 0;
      }

      /* DASH COOLDOWN */
      #dashCooldown {
        position: absolute;
        top: 20px;
        right: 20px;
        width: 150px;
        height: 20px;
        background-color: rgba(100, 100, 100, 0.5);
        border: 2px solid black;
        border-radius: 5px;
        overflow: hidden;
        display: none;
        z-index: 2000;
      }
      #dashCooldownBar {
        width: 100%;
        height: 100%;
        background-color: lightblue;
        transition: width 0.1s linear;
      }
    </style>
  </head>

  <body>
    <!-- Dash cooldown bar -->
    <div id="dashCooldown">
      <div id="dashCooldownBar"></div>
    </div>

    <!-- USERNAME POPUP -->
    <div id="usernamePopup">
      <p id="onlinePlayers" style="margin: 0px;">online players: 0</p>
      <p id="version" style="margin-top: 0px;"></p>
      <h1>Online Game:Remastered</h1>
      <input
        onkeydown="return /[a-z]/i.test(event.key)"
        maxlength="25"
        placeholder="username"
        id="usernameInput"
      />
      <br />
      <button id="usernameButton" style="display: none;">submit</button>
      <p id="errorText" style="display: none;">get the new version to play bruh</p>
    </div>

    <!-- MAIN GAME AREA (hidden until username is entered) -->
    <div id="main" style="display: none;">
      <p id="cords"></p>
      <p id="online-text">online players: 0</p>
      <p id="object-text" style="margin: 0px;">total objects: 0</p>

      <!-- Container for other players -->
      <div id="playerContainer"></div>

      <!-- Local player -->
      <div id="player">
        <div id="sword"></div>
        <div id="bow"></div>
      </div>

      <!-- Inventory side (Tab) -->
      <div id="invMain">
        <h1 style="margin-top: 0px;">Players</h1>
        <div id="playerList"></div>
      </div>

      <!-- Chat area & input -->
      <div id="chatArea"></div>
      <input id="messageInput" placeholder="press enter to message" maxlength="50" />

      <!-- Quick slots -->
      <div id="slots">
        <div class="slot" id="slot-1">1</div>
        <div class="slot" id="slot-2">2<br>create</div>
        <div class="slot" id="slot-3">3<br>sword</div>
        <div class="slot" id="slot-4">4<br>bow</div>
        <div class="slot" id="slot-5">5</div>
      </div>

      <!-- Example block (the "wall") -->
      <div id="wall"></div>

      <!-- Hover element for block creation -->
      <div id="hover"></div>
      <div id="hoverChild" style="position: absolute;">
        <p id="hoverText">F to change object</p>
        <div id="blockSelector">
          <div id="sSquare" style="background-color: blue;"></div>
          <div id="sRect"></div>
          <div id="sCircle"></div>
          <div id="sSign"></div>
          <p id="signText">sign</p>
        </div>
      </div>

      <!-- Health bar at the bottom -->
      <div id="healthBarBack">
        <div id="healthBar"></div>
      </div>

      <!-- Color picker -->
      <div id="colorPicker">
        <div class="color-section" style="background-color: red;"></div>
        <div class="color-section" style="background-color: orange;"></div>
        <div class="color-section" style="background-color: yellow;"></div>
        <div class="color-section" style="background-color: green;"></div>
        <div class="color-section" style="background-color: cyan;"></div>
        <div class="color-section" style="background-color: blue;"></div>
        <div class="color-section" style="background-color: purple;"></div>
        <div class="color-section" style="background-color: gray; text-align: center; font-size: 25px;">?</div>
      </div>

      <!-- Inventory (press 'e') -->
      <div id="inventory">
        <h1>inventory</h1>
      </div>
    </div>

    <!-- ============================================= -->
    <!--  JAVASCRIPT CODE (BUGFIXED)                  -->
    <!-- ============================================= -->
    <script type="module">
      // Throttle function for expensive events (e.g., mousemove)
      function throttle(fn, limit) {
        let inThrottle;
        return function(...args) {
          if (!inThrottle) {
            fn.apply(this, args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
          }
        };
      }

      // ==============================
      //   Firebase Setup
      // ==============================
      import { 
        initializeApp 
      } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
      import {
        getDatabase,
        ref,
        set,
        onDisconnect,
        onChildAdded,
        onChildRemoved,
        onValue,
        get,
        push,
        remove
      } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-database.js";

      const firebaseConfig = {
        apiKey: "AIzaSyBdqoHJ58sFCcKpdHLw7mKUg_Bpi7xc7ok",
        authDomain: "game-10962.firebaseapp.com",
        databaseURL: "https://game-10962-default-rtdb.firebaseio.com",
        projectId: "game-10962",
        storageBucket: "game-10962.firebasestorage.app",
        messagingSenderId: "817447482404",
        appId: "1:817447482404:web:2cb0dd8608daf70197d4b1",
        measurementId: "G-W44ZYYMKLX"
      };
      const app = initializeApp(firebaseConfig);
      const database = getDatabase(app);

      // ==============================
      //   DOM Elements
      // ==============================
      const playerElem       = document.getElementById("player");
      const inputElem        = document.getElementById("messageInput");
      const invMainElem      = document.getElementById("invMain");
      const cordsText        = document.getElementById("cords");
      const onlineText       = document.getElementById("online-text");
      const hoverElement     = document.getElementById("hover");
      const objectText       = document.getElementById("object-text");
      const swordElem        = document.getElementById("sword");
      const bowElem          = document.getElementById("bow");
      const healthBarElem    = document.getElementById("healthBar");
      const inventoryElem    = document.getElementById("inventory");
      const hoverChildElem   = document.getElementById("hoverChild");
      const wallElem         = document.getElementById("wall");
      const chatArea         = document.getElementById("chatArea");
      const colorPickerElem  = document.getElementById("colorPicker");
      const dashCooldownElem = document.getElementById("dashCooldown");
      const dashCooldownBar  = document.getElementById("dashCooldownBar");

      const messageRef = ref(database, "messages/");
      const blockRef   = ref(database, "blocks/");
      const terrainRef = ref(database, "terrain/");
      const arrowsRef  = ref(database, "arrows/");
      const playerRefAll= ref(database, "players/");

      // ==============================
      //   Game State
      // ==============================
      let gameVersion = 1.2;
      document.getElementById("version").textContent = "version " + gameVersion;

      let pos = {
        xSize: 50,
        ySize: 50,
        x: window.innerWidth / 2 - 25,
        y: window.innerHeight / 2 - 50,
        username: "",
        color: "red",
        angle: 0,
        health: 100,
        heldItem: "none",
        clicked: false,
        deleteSword: false
      };

      // Unique ID for this player
      let playerID    = Math.floor(Math.random() * 10000000000) + 1;
      let playerRef   = ref(database, "players/" + playerID);

      // Bow mechanics
      let canShootBow  = true;
      const bowCooldown= 1000;
      const arrowSpeed = 20;
      const arrowDamage= 25;
      const arrowRange = 1000;

      // Sword
      let canUseSword = true;

      // Blocks & Terrain
      let blocks      = [];
      let terrainList = [];

      // Movement & game flags
      let keys        = {};
      let bKey        = false; // toggled by 'b' => break-sword mode
      let rotation    = 0;     
      let inGame      = false;
      let dead        = false;
      let worldX      = 0;
      let worldY      = 0;

      const MOVE_SPEED  = 3;
      const BOUND_LIMIT = 5000; // unify movement boundary

      // Quick slots
      let currentSlot   = 1;
      let objectSelector= true; 
      let currentObject = "cube"; 
      // Rate-limiting for sending position updates
      let sendValue     = 0;

      // Dash
      let canDash       = true;
      let isInvincible  = false;
      const dashDistance= 100;
      const dashDuration= 500;
      const dashCooldown= 2000;

      // ==============================
      //   Init
      // ==============================
      // Remove this player's data from DB on disconnect
      onDisconnect(playerRef).remove();

      // DO NOT clear all players on load (removed set(playerRefAll, null);)

      playerElem.style.left = pos.x + "px";
      playerElem.style.top  = pos.y + "px";

      // Check game version in DB
      get(ref(database, "/version")).then((snapshot) => {
        if (snapshot.exists()) {
          const versionFromDB = snapshot.val();
          if (gameVersion >= versionFromDB) {
            document.getElementById("version").style.color = "green";
            document.getElementById("usernameButton").style.display = "block";
          } else {
            document.getElementById("version").style.color = "red";
            document.getElementById("usernameButton").remove();
            document.getElementById("errorText").style.display = "block";
          }
        }
      });

      // Highlight slots
      const slots = document.getElementsByClassName("slot");
      function updateSlotColors() {
        for (let i = 0; i < slots.length; i++) {
          if (i + 1 === currentSlot) {
            slots[i].style.backgroundColor = "rgb(100, 100, 100)";
          } else {
            slots[i].style.backgroundColor = "rgb(187, 185, 185)";
          }
        }
      }
      for (let i = 0; i < slots.length; i++) {
        slots[i].addEventListener("click", () => {
          currentSlot = i + 1;
          updateSlotColors();
        });
      }
      updateSlotColors();

      // ==============================
      //   Username Submission
      // ==============================
      document.getElementById("usernameButton").addEventListener("click", () => {
        const inputVal = document.getElementById("usernameInput").value.replace(/\s+/g, '');
        if (!inputVal) return;
        pos.username = inputVal;

        // Announce system join (now it stays in DB â€” removed "set(messageRef, null)")
        push(messageRef, {
          username: "System",
          message: pos.username + " has joined the game",
          color: pos.color
        });

        document.getElementById("usernamePopup").style.display = "none";
        document.getElementById("main").style.display = "block";

        inGame = true;
        gameLoop();
        getTerrain();
        setupBlockListeners();
        setupArrowListeners();
      });

      // ==============================
      //   Event Listeners
      // ==============================
      document.addEventListener("keydown", handleKeyDown);
      document.addEventListener("keyup", handleKeyUp);

      function handleKeyDown(event) {
        keys[event.key] = true;

        // Toggle sword "destroy" mode with B
        if (event.key === 'b' && inGame && document.activeElement !== inputElem) {
          bKey = !bKey;
          pos.deleteSword = bKey;
          set(playerRef, pos);
        }
        // Switch block object type UI with F
        if (event.key === 'f' && inGame && document.activeElement !== inputElem && currentSlot === 2) {
          objectSelector = !objectSelector;
          updateHoverVisuals();
        }
        // Rotate block with R
        if (event.key === 'r' && inGame && document.activeElement !== inputElem && currentSlot === 2) {
          rotation += 90;
          updateHoverVisuals();
        }
        // Toggle inventory with E
        if (event.key === 'e' && inGame && document.activeElement !== inputElem) {
          inventoryElem.style.display = (inventoryElem.style.display === "none") ? "block" : "none";
        }
        // Chat box with Enter
        if (event.key === 'Enter') {
          if (document.activeElement !== inputElem) {
            inputElem.focus();
          } else {
            if (inputElem.value !== "") {
              // Push the chat message (no more set(messageRef, null);)
              push(messageRef, {
                username: pos.username,
                message: inputElem.value,
                color: pos.color
              });
            }
            inputElem.value = "";
            inputElem.blur();
          }
        }
        // Tab => Show "Players" panel
        if (event.key === 'Tab') {
          event.preventDefault();
          invMainElem.style.display = (invMainElem.style.display === "none") ? "block" : "none";
        }
        // Sword usage with space bar (slot=3)
        if (event.key === ' ' && currentSlot === 3 && canUseSword) {
          swordAttack();
        }
        // Bow usage with space bar (slot=4)
        if (event.key === ' ' && currentSlot === 4 && canShootBow) {
          shootArrow();
        }
        // Dash with Q
        if (event.key === 'q' && inGame && canDash) {
          handleDash();
        }
      }
      function handleKeyUp(event) {
        delete keys[event.key];
      }

      // Mousemove: rotate player + move hover
      const handleMouseMove = throttle((event) => {
        if (objectSelector) {
          hoverElement.style.left = 
            event.clientX - parseInt(hoverElement.style.width) / 2 + "px";
          hoverElement.style.top = 
            event.clientY - parseInt(hoverElement.style.height) / 2 + "px";
        }
        let mouseX = event.clientX;
        let mouseY = event.clientY;
        let playerRect = playerElem.getBoundingClientRect();
        let playerCenterX = playerRect.left + playerRect.width / 2;
        let playerCenterY = playerRect.top + playerRect.height / 2;
        let angle = Math.atan2(mouseY - playerCenterY, mouseX - playerCenterX);
        pos.angle = (angle * 180 / Math.PI) | 0;
        playerElem.style.transform = `translate(-50%, -50%) rotate(${pos.angle}deg)`;
      }, 16);
      document.addEventListener("mousemove", handleMouseMove);

      // Click => place block / sword / bow
      let canPlaceBlock = true;
      const blockCooldown = 125;
      document.addEventListener("click", (event) => {
        // Placing a block
        if (
          currentSlot === 2 &&
          canPlaceBlock &&
          !dead &&
          objectSelector &&
          document.activeElement !== inputElem
        ) {
          const clickedElem = document.elementFromPoint(event.clientX, event.clientY);
          if (!clickedElem) return;

          // Avoid placing on player, wall, or existing block
          if (clickedElem.id === "player" || clickedElem.id === "wall" || clickedElem.className === "block") {
            return;
          }
          const color = (pos.color === "red") ? "blue" : pos.color; 
          push(blockRef, {
            x: event.clientX - worldX - 25,
            y: event.clientY - worldY - 25,
            color: color,
            kind: currentObject,
            rotation: rotation
          });
          canPlaceBlock = false;
          setTimeout(() => { canPlaceBlock = true; }, blockCooldown);
        }

        // Sword usage if slot=3 (mouse click)
        if (currentSlot === 3 && canUseSword && document.activeElement !== inputElem) {
          swordAttack();
        }
        // Bow usage if slot=4 (mouse click)
        if (currentSlot === 4 && canShootBow && document.activeElement !== inputElem) {
          shootArrow();
        }
      });

      // ==============================
      //   Functions
      // ==============================
      function swordAttack() {
        // Sword swings forward
        swordElem.style.transform = "rotate(0deg)";
        pos.clicked = true;
        canUseSword = false;
        set(playerRef, pos); // so others see you attacking

        // Return sword after 200ms
        setTimeout(() => {
          swordElem.style.transform = "rotate(90deg)";
          pos.clicked = false;
          set(playerRef, pos);
        }, 200);

        // Re-enable sword usage after ~500ms
        setTimeout(() => {
          canUseSword = true;
        }, 500);
      }

      function shootArrow() {
        canShootBow = false;
        setTimeout(() => {
          canShootBow = true;
        }, bowCooldown);

        let rad = (pos.angle * Math.PI) / 180;
        let vx  = Math.cos(rad) * arrowSpeed;
        let vy  = Math.sin(rad) * arrowSpeed;

        push(arrowsRef, {
          shooterID: playerID,
          x: pos.x,
          y: pos.y,
          vx: vx,
          vy: vy,
          angle: pos.angle
        });
      }

      function handleDash() {
        canDash = false;
        isInvincible = true;

        if (keys["a"] || keys["ArrowLeft"]) {
          worldX = Math.min(worldX + dashDistance, BOUND_LIMIT);
          pos.x  = Math.max(pos.x - dashDistance, -BOUND_LIMIT);
        }
        if (keys["d"] || keys["ArrowRight"]) {
          worldX = Math.max(worldX - dashDistance, -BOUND_LIMIT);
          pos.x  = Math.min(pos.x + dashDistance,  BOUND_LIMIT);
        }
        if (keys["w"] || keys["ArrowUp"]) {
          worldY = Math.min(worldY + dashDistance, BOUND_LIMIT);
          pos.y  = Math.max(pos.y - dashDistance, -BOUND_LIMIT);
        }
        if (keys["s"] || keys["ArrowDown"]) {
          worldY = Math.max(worldY - dashDistance, -BOUND_LIMIT);
          pos.y  = Math.min(pos.y + dashDistance,  BOUND_LIMIT);
        }

        dashCooldownElem.style.display = "block";
        dashCooldownBar.style.width    = "100%";

        let cooldownProgress = 100;
        const cooldownInterval = setInterval(() => {
          cooldownProgress -= 100 / (dashCooldown / 100);
          dashCooldownBar.style.width = `${cooldownProgress}%`;

          if (cooldownProgress <= 0) {
            clearInterval(cooldownInterval);
            dashCooldownElem.style.display = "none";
            canDash = true;
          }
        }, 100);

        setTimeout(() => {
          isInvincible = false;
        }, dashDuration);
      }

      // ==============================
      //   Game Loop
      // ==============================
      function gameLoop() {
        if (!inGame) return;

        // Movement (only if chat not focused)
        if (document.activeElement !== inputElem && !dead) {
          if (keys["a"] || keys["ArrowLeft"]) {
            worldX = Math.min(worldX + MOVE_SPEED, BOUND_LIMIT);
            pos.x  = Math.max(pos.x - MOVE_SPEED, -BOUND_LIMIT);
          }
          if (keys["d"] || keys["ArrowRight"]) {
            worldX = Math.max(worldX - MOVE_SPEED, -BOUND_LIMIT);
            pos.x  = Math.min(pos.x + MOVE_SPEED,  BOUND_LIMIT);
          }
          if (keys["w"] || keys["ArrowUp"]) {
            worldY = Math.min(worldY + MOVE_SPEED, BOUND_LIMIT);
            pos.y  = Math.max(pos.y - MOVE_SPEED, -BOUND_LIMIT);
          }
          if (keys["s"] || keys["ArrowDown"]) {
            worldY = Math.max(worldY - MOVE_SPEED, -BOUND_LIMIT);
            pos.y  = Math.min(pos.y + MOVE_SPEED,  BOUND_LIMIT);
          }

          // Quick slot shortcuts
          if (keys["1"]) currentSlot = 1;
          if (keys["2"]) currentSlot = 2;
          if (keys["3"]) currentSlot = 3;
          if (keys["4"]) currentSlot = 4;
          if (keys["5"]) currentSlot = 5;
        }

        // Update UI
        cordsText.textContent = "cords: " + worldX + ", " + worldY;
        wallElem.style.left   = (worldX + 500) + "px";
        wallElem.style.top    = (worldY + 500) + "px";
        hoverChildElem.style.display = hoverElement.style.display;
        hoverChildElem.style.left    = hoverElement.style.left;
        hoverChildElem.style.top     = hoverElement.style.top;
        healthBarElem.style.width    = pos.health + "%";

        document.getElementById("blockSelector").style.display = objectSelector ? "none" : "block";

        // Hover element for the create slot
        hoverElement.style.display = (currentSlot === 2) ? "block" : "none";

        // Sword / Bow
        if (currentSlot === 3) {
          swordElem.style.display = "block";
          bowElem.style.display   = "none";
          pos.heldItem = "sword";
        } else if (currentSlot === 4) {
          swordElem.style.display = "none";
          bowElem.style.display   = "block";
          pos.heldItem = "bow";
        } else {
          swordElem.style.display = "none";
          bowElem.style.display   = "none";
          pos.heldItem = "none";
        }

        // Break-sword color
        swordElem.style.backgroundColor = bKey ? "red" : "black";

        // Health regeneration (fixed else-if so we don't double heal below 50)
        if (pos.health < 50) {
          pos.health += 0.125;
          if (pos.health > 50) pos.health = 50; // clamp intermediate step
        } 
        else if (pos.health < 100) {
          pos.health += 0.0625;
        }
        if (pos.health > 100) {
          pos.health = 100;
        }

        // Collisions
        updatePlayerBlockCollisions();
        updatePlayerTerrainCollisions();

        // Local break-sword collision
        if (pos.deleteSword) {
          const localSwordRect = swordElem.getBoundingClientRect();
          for (let i = 0; i < blocks.length; i++) {
            const blockRect = blocks[i].getBoundingClientRect();
            if (
              localSwordRect.left < blockRect.right &&
              localSwordRect.right > blockRect.left &&
              localSwordRect.top < blockRect.bottom &&
              localSwordRect.bottom > blockRect.top
            ) {
              remove(ref(database, "blocks/" + blocks[i].dataset.id));
              blocks[i].remove();
              blocks.splice(i, 1);
              i--;
            }
          }
        }

        // Update arrow positions & collisions
        updateArrows();

        // Update block positions
        blocks.forEach((block) => {
          let inViewX = block.x + worldX >= -200 && block.x + worldX <= window.innerWidth + 200;
          let inViewY = block.y + worldY >= -200 && block.y + worldY <= window.innerHeight + 200;
          if (inViewX && inViewY) {
            block.style.left = (worldX + block.x) + "px";
            block.style.top  = (worldY + block.y) + "px";
            block.style.display = "block";
          } else {
            block.style.display = "none";
          }
        });

        // Update terrain positions
        renderTerrain();

        // Update slot colors each frame
        updateSlotColors();
        // Update object count
        getObjectCount();

        // Rate-limit sending player data
        if (sendValue >= 5) {
          sendValue = 0;
          set(playerRef, pos);
        }
        sendValue++;

        requestAnimationFrame(gameLoop);
      }

      function updatePlayerBlockCollisions() {
        const playerRect = playerElem.getBoundingClientRect();
        blocks.forEach((block) => {
          const blockRect = block.getBoundingClientRect();
          // Left (A)
          if ((keys["a"] || keys["ArrowLeft"]) &&
            playerRect.left < blockRect.right &&
            playerRect.left > blockRect.left &&
            playerRect.bottom > blockRect.top &&
            playerRect.top < blockRect.bottom
          ) {
            pos.x += MOVE_SPEED;
            worldX -= MOVE_SPEED;
          }
          // Right (D)
          if ((keys["d"] || keys["ArrowRight"]) &&
            playerRect.right > blockRect.left &&
            playerRect.right < blockRect.right &&
            playerRect.bottom > blockRect.top &&
            playerRect.top < blockRect.bottom
          ) {
            pos.x -= MOVE_SPEED;
            worldX += MOVE_SPEED;
          }
          // Up (W)
          if ((keys["w"] || keys["ArrowUp"]) &&
            playerRect.top < blockRect.bottom &&
            playerRect.top > blockRect.top &&
            playerRect.right > blockRect.left &&
            playerRect.left < blockRect.right
          ) {
            pos.y += MOVE_SPEED;
            worldY -= MOVE_SPEED;
          }
          // Down (S)
          if ((keys["s"] || keys["ArrowDown"]) &&
            playerRect.bottom > blockRect.top &&
            playerRect.bottom < blockRect.bottom &&
            playerRect.right > blockRect.left &&
            playerRect.left < blockRect.right
          ) {
            pos.y -= MOVE_SPEED;
            worldY += MOVE_SPEED;
          }
        });
      }

      function updatePlayerTerrainCollisions() {
        const playerRect = playerElem.getBoundingClientRect();
        terrainList.forEach((item) => {
          const blockRect = item.getBoundingClientRect();
          // Left (A)
          if ((keys["a"] || keys["ArrowLeft"]) &&
            playerRect.left < blockRect.right &&
            playerRect.left > blockRect.left &&
            playerRect.bottom > blockRect.top &&
            playerRect.top < blockRect.bottom
          ) {
            pos.x += MOVE_SPEED;
            worldX -= MOVE_SPEED;
          }
          // Right (D)
          if ((keys["d"] || keys["ArrowRight"]) &&
            playerRect.right > blockRect.left &&
            playerRect.right < blockRect.right &&
            playerRect.bottom > blockRect.top &&
            playerRect.top < blockRect.bottom
          ) {
            pos.x -= MOVE_SPEED;
            worldX += MOVE_SPEED;
          }
          // Up (W)
          if ((keys["w"] || keys["ArrowUp"]) &&
            playerRect.top < blockRect.bottom &&
            playerRect.top > blockRect.top &&
            playerRect.right > blockRect.left &&
            playerRect.left < blockRect.right
          ) {
            pos.y += MOVE_SPEED;
            worldY -= MOVE_SPEED;
          }
          // Down (S)
          if ((keys["s"] || keys["ArrowDown"]) &&
            playerRect.bottom > blockRect.top &&
            playerRect.bottom < blockRect.bottom &&
            playerRect.right > blockRect.left &&
            playerRect.left < blockRect.right
          ) {
            pos.y -= MOVE_SPEED;
            worldY += MOVE_SPEED;
          }
        });
      }

      function updateArrows() {
        const arrowElements = document.getElementsByClassName("arrow");
        for (let i = arrowElements.length - 1; i >= 0; i--) {
          let arrowEl = arrowElements[i];
          // Movement
          arrowEl.x += arrowEl.vx;
          arrowEl.y += arrowEl.vy;
          arrowEl.distanceTraveled = arrowEl.distanceTraveled || 0;
          arrowEl.distanceTraveled += Math.sqrt(arrowEl.vx * arrowEl.vx + arrowEl.vy * arrowEl.vy);

          // Remove arrow if exceeded range
          if (arrowEl.distanceTraveled > arrowRange) {
            removeArrowFromDB(arrowEl.dataset.id);
            continue;
          }
          arrowEl.style.left = (worldX + arrowEl.x) + "px";
          arrowEl.style.top  = (worldY + arrowEl.y) + "px";

          const arrowRect = arrowEl.getBoundingClientRect();

          // Collision with blocks
          for (let j = 0; j < blocks.length; j++) {
            const blockRect = blocks[j].getBoundingClientRect();
            if (
              arrowRect.left < blockRect.right &&
              arrowRect.right > blockRect.left &&
              arrowRect.top < blockRect.bottom &&
              arrowRect.bottom > blockRect.top
            ) {
              removeArrowFromDB(arrowEl.dataset.id);
              // Remove block from DB
              remove(ref(database, "blocks/" + blocks[j].dataset.id));
              blocks[j].remove();
              blocks.splice(j, 1);
              break;
            }
          }

          // Collision with terrain
          for (let j = 0; j < terrainList.length; j++) {
            const terrainRect = terrainList[j].getBoundingClientRect();
            if (
              arrowRect.left < terrainRect.right &&
              arrowRect.right > terrainRect.left &&
              arrowRect.top < terrainRect.bottom &&
              arrowRect.bottom > terrainRect.top
            ) {
              removeArrowFromDB(arrowEl.dataset.id);
              break;
            }
          }

          // Collision with local player
          const playerRect = playerElem.getBoundingClientRect();
          if (
            arrowRect.left < playerRect.right &&
            arrowRect.right > playerRect.left &&
            arrowRect.top < playerRect.bottom &&
            arrowRect.bottom > playerRect.top
          ) {
            if (parseInt(arrowEl.dataset.shooter) !== playerID && !dead) {
              pos.health -= arrowDamage;
              if (pos.health <= 0) {
                handleLocalDeath();
              }
              removeArrowFromDB(arrowEl.dataset.id);
            }
            continue; 
          }

          // Collision with other players
          const otherPlayers = document.getElementsByClassName("otherPlayer");
          for (let k = 0; k < otherPlayers.length; k++) {
            const op = otherPlayers[k];
            const opRect = op.getBoundingClientRect();
            if (
              arrowRect.left < opRect.right &&
              arrowRect.right > opRect.left &&
              arrowRect.top < opRect.bottom &&
              arrowRect.bottom > opRect.top
            ) {
              if (parseInt(arrowEl.dataset.shooter) !== parseInt(op.id)) {
                removeArrowFromDB(arrowEl.dataset.id);
              }
              break;
            }
          }
        }
      }

      function handleLocalDeath() {
        pos.health = 100;
        dead = true;
        let originalColor = pos.color;
        let originalBg    = playerElem.style.backgroundColor;
        pos.color = "rgba(100, 100, 100, 0.5)";
        playerElem.style.backgroundColor = "rgba(100, 100, 100, 0.5)";
        setTimeout(() => {
          pos.color = originalColor;
          playerElem.style.backgroundColor = originalBg;
          dead = false;
        }, 5000);
      }

      function removeArrowFromDB(arrowID) {
        const arrElems = document.getElementsByClassName("arrow");
        for (let i = 0; i < arrElems.length; i++) {
          if (arrElems[i].dataset.id === arrowID) {
            arrElems[i].remove();
            break;
          }
        }
        remove(ref(database, "arrows/" + arrowID));
      }

      // ==============================
      //   DB Listeners
      // ==============================
      // Messages
      onChildAdded(messageRef, (snapshot) => {
        const message = snapshot.val();
        if (!message) return;
        let messageElement;

        // If message contains "***", enlarge it
        if (message.message && message.message.includes("***")) {
          message.message = message.message.replace("***", "");
          messageElement  = document.createElement("h1");
        } else {
          messageElement  = document.createElement("p");
        }
        messageElement.id = "playerMessage";
        if (message.color && message.color !== "red") {
          messageElement.style.color = message.color;
        }
        if (message.username === "System") {
          messageElement.style.fontStyle = "italic";
          messageElement.style.color     = "gray";
        }

        // handle /playsound
        if (message.message && message.message.includes("/playsound")) {
          let [cmd, sound] = message.message.split(" ");
          let audioElement  = document.createElement("audio");
          audioElement.src  = "https://raw.githubusercontent.com/seaotter6382/seaotter6382.github.io/refs/heads/main/sounds/" + sound + ".mp3";
          audioElement.autoplay = true;
          document.body.appendChild(audioElement);
        }
        // handle /clear
        if (message.message === "/clear") {
          set(blockRef, null);
          blocks.forEach((block) => block.remove());
          blocks = [];
          // Provide a system message about clearing
          push(messageRef, {
            username: "System",
            message: (message.username + " has cleared the blocks"),
            color: message.color
          });
          return;
        }

        messageElement.textContent = message.username + ": " + message.message;
        chatArea.appendChild(messageElement);
        chatArea.scrollTop = chatArea.scrollHeight;
      });

      // Players
      onValue(playerRefAll, (snapshot) => {
        if (!snapshot.exists()) return;
        const allPlayers = snapshot.val() || {};

        // Update side panel player list
        const playerListElem = document.getElementById("playerList");
        playerListElem.innerHTML = "";

        const totalPlayers = Object.keys(allPlayers).length;
        onlineText.textContent = "online players: " + totalPlayers;
        document.getElementById("onlinePlayers").textContent = "online players: " + totalPlayers;

        // Generate/Update each
        for (let key in allPlayers) {
          const otherPlayer = allPlayers[key];
          if (!otherPlayer) continue;

          // Side panel
          let newText = document.createElement("p");
          newText.textContent = otherPlayer.username;
          newText.style.textAlign = "center";
          newText.style.margin    = "0px";
          if (otherPlayer.color !== "red") {
            newText.style.color = otherPlayer.color;
          }
          playerListElem.appendChild(newText);

          // If not me, draw / update other player
          if (parseInt(key) !== playerID) {
            updateOtherPlayer(key, otherPlayer);
          }
        }

        // Remove DOM players that are no longer in DB
        let existingPlayers = document.getElementsByClassName("otherPlayer");
        for (let i = existingPlayers.length - 1; i >= 0; i--) {
          let e = existingPlayers[i];
          if (!allPlayers[e.id]) {
            // remove from DOM
            e.remove();
            // remove healthbars, username, etc.
            const uh = document.getElementById(e.id + "username");
            if (uh) uh.remove();
            const hb = document.getElementById(e.id + "healthBack");
            if (hb) hb.remove();
          }
        }
      });

      // Blocks
      function setupBlockListeners() {
        onChildAdded(blockRef, (snapshot) => {
          const blockData = snapshot.val();
          if (!blockData) return;

          let newBlock = document.createElement("div");
          // Use a unique ID
          newBlock.id         = "block-" + snapshot.key;
          newBlock.dataset.id = snapshot.key;
          newBlock.classList.add("block");

          newBlock.style.position = "absolute";
          newBlock.style.zIndex   = -1000;
          newBlock.style.backgroundColor = blockData.color;
          newBlock.style.transform      = "rotate(" + blockData.rotation + "deg)";

          // Basic size
          if (blockData.kind === "rect") {
            newBlock.style.width  = "25px";
            newBlock.style.height = "50px";
          } else {
            newBlock.style.width  = "50px";
            newBlock.style.height = "50px";
          }
          if (blockData.kind === "circle") {
            newBlock.style.borderRadius = "50%";
          }
          if (blockData.kind === "sign") {
            newBlock.textContent    = "sign";
            newBlock.contentEditable= true;
            // Force no rotation so text is easier to read
            newBlock.style.transform= "rotate(0deg)";
          }

          // For simpler tracking
          newBlock.x = blockData.x;
          newBlock.y = blockData.y;
          newBlock.style.left = (worldX + newBlock.x) + "px";
          newBlock.style.top  = (worldY + newBlock.y) + "px";

          document.body.appendChild(newBlock);
          blocks.push(newBlock);
        });
      }

      // Arrows
      function setupArrowListeners() {
        onChildAdded(arrowsRef, (snapshot) => {
          const arrowData = snapshot.val();
          if (!arrowData) return;

          let arrowDiv    = document.createElement("div");
          arrowDiv.classList.add("arrow");
          arrowDiv.style.position = "absolute";
          arrowDiv.style.width    = "6px";
          arrowDiv.style.height   = "6px";
          arrowDiv.style.backgroundColor = "black";
          arrowDiv.dataset.id     = snapshot.key;
          arrowDiv.dataset.shooter= arrowData.shooterID;
          arrowDiv.x              = arrowData.x;
          arrowDiv.y              = arrowData.y;
          arrowDiv.vx             = arrowData.vx;
          arrowDiv.vy             = arrowData.vy;
          arrowDiv.angle          = arrowData.angle;
          arrowDiv.distanceTraveled = 0;
          arrowDiv.style.left     = (worldX + arrowDiv.x) + "px";
          arrowDiv.style.top      = (worldY + arrowDiv.y) + "px";
          arrowDiv.style.transform= `rotate(${arrowDiv.angle}deg)`;

          document.body.appendChild(arrowDiv);
        });
      }

      function updateOtherPlayer(key, otherPlayer) {
        let otherPlayerDiv       = document.getElementById(key);
        let otherPlayerUsername  = document.getElementById(key + "username");
        let otherPlayerHealthBack= document.getElementById(key + "healthBack");
        let otherPlayerHealth    = document.getElementById(key + "health");
        let otherPlayerSword     = document.getElementById(key + "sword");
        let otherPlayerBow       = document.getElementById(key + "bow");

        // Create DOM if missing
        if (!otherPlayerDiv) {
          otherPlayerDiv = document.createElement("div");
          otherPlayerDiv.id = key;
          otherPlayerDiv.classList.add("otherPlayer");
          otherPlayerDiv.style.position = "absolute";
          document.getElementById("playerContainer").appendChild(otherPlayerDiv);
        }
        if (!otherPlayerUsername) {
          otherPlayerUsername = document.createElement("p");
          otherPlayerUsername.id = key + "username";
          otherPlayerUsername.style.width = "500px";
          otherPlayerUsername.style.textAlign = "center";
          otherPlayerUsername.style.position  = "absolute";
          otherPlayerUsername.style.fontWeight= "bold";
          otherPlayerUsername.style.zIndex    = 100;
          document.getElementById("playerContainer").appendChild(otherPlayerUsername);
        }
        if (!otherPlayerHealthBack) {
          otherPlayerHealthBack = document.createElement("div");
          otherPlayerHealthBack.id = key + "healthBack";
          otherPlayerHealthBack.style.height = "10px";
          otherPlayerHealthBack.style.width  = "100px";
          otherPlayerHealthBack.style.backgroundColor = "rgb(75, 75, 75)";
          otherPlayerHealthBack.style.position = "absolute";
          otherPlayerHealthBack.style.zIndex    = 99;
          document.getElementById("playerContainer").appendChild(otherPlayerHealthBack);
        }
        if (!otherPlayerHealth) {
          otherPlayerHealth = document.createElement("div");
          otherPlayerHealth.id = key + "health";
          otherPlayerHealth.style.height = "10px";
          otherPlayerHealth.style.width  = "100px";
          otherPlayerHealth.style.backgroundColor = "rgb(255, 0, 0)";
          otherPlayerHealth.style.position = "absolute";
          otherPlayerHealth.style.zIndex    = 100;
          otherPlayerHealthBack.appendChild(otherPlayerHealth);
        }
        if (!otherPlayerSword) {
          otherPlayerSword = document.createElement("div");
          otherPlayerSword.id = key + "sword";
          otherPlayerSword.style.height = "75px";
          otherPlayerSword.style.width  = "10px";
          otherPlayerSword.style.backgroundColor = "rgb(0, 0, 0)";
          otherPlayerSword.style.position = "absolute";
          otherPlayerSword.style.transformOrigin = "bottom";
          otherPlayerSword.style.transform = "rotate(90deg)";
          otherPlayerDiv.appendChild(otherPlayerSword);
        }
        if (!otherPlayerBow) {
          otherPlayerBow = document.createElement("div");
          otherPlayerBow.id = key + "bow";
          otherPlayerBow.style.height = "70px";
          otherPlayerBow.style.width  = "5px";
          otherPlayerBow.style.backgroundColor = "brown";
          otherPlayerBow.style.position = "absolute";
          otherPlayerBow.style.transformOrigin = "center";
          otherPlayerBow.style.transform = "rotate(90deg)";
          otherPlayerBow.style.top = "-30px";
          otherPlayerBow.style.left= "40px";
          otherPlayerDiv.appendChild(otherPlayerBow);
        }

        // Update item display
        otherPlayerSword.style.display = (otherPlayer.heldItem === "sword") ? "block" : "none";
        otherPlayerBow.style.display   = (otherPlayer.heldItem === "bow")   ? "block" : "none";

        // Position
        otherPlayerDiv.style.left   = (worldX + otherPlayer.x) + "px";
        otherPlayerDiv.style.top    = (worldY + otherPlayer.y) + "px";
        otherPlayerHealth.style.width = otherPlayer.health + "%";
        otherPlayerDiv.style.transform  = `translate(-50%, -50%) rotate(${otherPlayer.angle}deg)`;
        otherPlayerUsername.textContent = otherPlayer.username;
        otherPlayerUsername.style.left  = 
          (worldX + otherPlayer.x + otherPlayerDiv.offsetWidth/2 - 
           otherPlayerUsername.offsetWidth/2 - 25) + "px";
        otherPlayerUsername.style.top   = (worldY + otherPlayer.y - 75) + "px";
        otherPlayerHealthBack.style.left= (worldX + otherPlayer.x + otherPlayerDiv.offsetWidth/2 - 75) + "px";
        otherPlayerHealthBack.style.top = (worldY + otherPlayer.y + 40) + "px";
        otherPlayerDiv.style.backgroundColor = otherPlayer.color;

        // Sword position
        otherPlayerSword.style.left = "45px";
        otherPlayerSword.style.top  = "-30px";

        // Break-sword mode
        if (otherPlayer.deleteSword === true) {
          otherPlayerSword.style.backgroundColor = "red";
          // Collisions for blocks with this remote player's sword
          const swordRect = otherPlayerSword.getBoundingClientRect();
          for (let i = 0; i < blocks.length; i++) {
            const blockRect = blocks[i].getBoundingClientRect();
            if (
              swordRect.left < blockRect.right &&
              swordRect.right > blockRect.left &&
              swordRect.top < blockRect.bottom &&
              swordRect.bottom > blockRect.top
            ) {
              remove(ref(database, "blocks/" + blocks[i].dataset.id));
              blocks[i].remove();
              blocks.splice(i, 1);
              i--;
            }
          }
        } else {
          otherPlayerSword.style.backgroundColor = "black";
        }

        // If other player is attacking (clicked)
        if (otherPlayer.clicked === true) {
          // Make the sword face forward
          otherPlayerSword.style.transform = "rotate(0deg)";
          // Return it after ~200ms
          setTimeout(() => {
            otherPlayerSword.style.transform = "rotate(90deg)";
          }, 200);
        }

        // Force 50x50
        otherPlayerDiv.style.width  = "50px";
        otherPlayerDiv.style.height = "50px";

        // Check if other player's sword hits local player
        if (otherPlayerSword.style.display === "block") {
          const localPlayerRect     = playerElem.getBoundingClientRect();
          const otherPlayerSwordRect= otherPlayerSword.getBoundingClientRect();
          if (
            otherPlayerSwordRect.left < localPlayerRect.right &&
            otherPlayerSwordRect.right > localPlayerRect.left &&
            otherPlayerSwordRect.top < localPlayerRect.bottom &&
            otherPlayerSwordRect.bottom > localPlayerRect.top
          ) {
            if (!dead && otherPlayer.clicked === true) {
              pos.health -= 5;
              if (pos.health <= 0) {
                handleLocalDeath();
              }
            }
          }
        }
      }

      function getObjectCount() {
        const blockElements = document.getElementsByClassName("block");
        objectText.textContent = "total objects: " + blockElements.length;
      }

      // ==============================
      //   Color Picker
      // ==============================
      const colorSections = document.querySelectorAll(".color-section");
      playerElem.addEventListener("click", (event) => {
        // If not on special slots, open color picker
        if (currentSlot !== 2 && currentSlot !== 3 && currentSlot !== 4 && currentSlot !== 5) {
          const rect = playerElem.getBoundingClientRect();
          const x = rect.left + rect.width / 2;
          const y = rect.top  + rect.height/ 2;
          colorPickerElem.style.left = (x - 100) + "px";
          colorPickerElem.style.top  = (y - 100) + "px";
          colorPickerElem.style.display = "flex";
          colorSections.forEach((section, index) => {
            section.style.opacity    = 0;
            section.style.visibility = "hidden";
            setTimeout(() => {
              section.style.visibility = "visible";
              section.style.opacity    = 1;
              section.style.transform  = `translate(var(--dx), var(--dy))`;
            }, index * 100);
          });
        }
      });

      colorSections.forEach((section) => {
        section.addEventListener("click", (event) => {
          const selectedColor = event.target.style.backgroundColor;
          section.style.transform = `translate(0px, 0px)`;
          colorSections.forEach((other) => {
            if (other !== section) {
              other.style.opacity    = 0;
              other.style.visibility = "hidden";
            }
          });
          setTimeout(() => {
            if (selectedColor === "gray") {
              // random color
              let randomColor = "#" + ((1 << 24) + 
                                (Math.floor(Math.random() * 256) << 16) +
                                (Math.floor(Math.random() * 256) << 8) +
                                 Math.floor(Math.random() * 256))
                                .toString(16)
                                .slice(1);
              pos.color = randomColor;
              playerElem.style.backgroundColor = randomColor;
            } else {
              pos.color = (selectedColor === "red") ? "rgb(255, 0, 0)" : selectedColor;
              playerElem.style.backgroundColor = pos.color;
            }
            colorPickerElem.style.display = "none";
            colorSections.forEach((other) => {
              other.style.transform  = "translate(0, 0)";
              other.style.opacity    = 1;
              other.style.visibility = "hidden";
            });
          }, 500);
        });
      });

      document.addEventListener("click", (event) => {
        if (!colorPickerElem.contains(event.target) && event.target !== playerElem) {
          colorSections.forEach((section) => {
            section.style.transform  = "translate(0, 0)";
            section.style.opacity    = 0;
            section.style.visibility = "hidden";
          });
          setTimeout(() => {
            colorPickerElem.style.display = "none";
          }, 500);
        }
      });

      // ==============================
      //   Terrain
      // ==============================
      function getTerrain() {
        get(terrainRef).then((snapshot) => {
          if (snapshot.exists()) {
            let data = snapshot.val();
            for (let key in data) {
              if (data.hasOwnProperty(key)) {
                const terrain = data[key];
                const newTerrain = document.createElement("div");
                newTerrain.style.left = (worldX + terrain.posX) + "px";
                newTerrain.style.top  = (worldY + terrain.posY) + "px";
                newTerrain.x = terrain.posX;
                newTerrain.y = terrain.posY;
                newTerrain.style.width  = terrain.size + "px";
                newTerrain.style.height = terrain.size + "px";
                newTerrain.id = key;
                newTerrain.classList.add("terrain");
                document.body.appendChild(newTerrain);
                terrainList.push(newTerrain);
              }
            }
          } else {
            // Create random terrain if none in DB
            for (let i = 0; i < 500; i++) {
              push(terrainRef, {
                posX: Math.floor(Math.random() * 10001) - 5000,
                posY: Math.floor(Math.random() * 10001) - 5000,
                size: Math.floor(Math.random() * (200 - 50 + 1)) + 50
              });
            }
          }
        });
      }

      function renderTerrain() {
        for (const item of terrainList) {
          let inViewX = (item.x + worldX >= -200 &&
                         item.x + worldX <= window.innerWidth + 200);
          let inViewY = (item.y + worldY >= -200 &&
                         item.y + worldY <= window.innerHeight + 200);
          if (inViewX && inViewY) {
            item.style.left = (worldX + item.x) + "px";
            item.style.top  = (worldY + item.y) + "px";
            item.style.display = "block";
          } else {
            item.style.display = "none";
          }
        }
      }

      // ==============================
      //   Block Selector Clicks
      // ==============================
      document.getElementById("sSquare").addEventListener("click", () => {
        currentObject = "cube";
        updateHoverVisuals();
      });
      document.getElementById("sRect").addEventListener("click", () => {
        currentObject = "rect";
        updateHoverVisuals();
      });
      document.getElementById("sCircle").addEventListener("click", () => {
        currentObject = "circle";
        updateHoverVisuals();
      });
      document.getElementById("sSign").addEventListener("click", () => {
        currentObject = "sign";
        updateHoverVisuals();
      });

      function updateHoverVisuals() {
        if (currentObject === "cube") {
          hoverElement.style.width = "50px";
          hoverElement.style.height= "50px";
          hoverElement.style.borderRadius = "0%";
        } else if (currentObject === "rect") {
          hoverElement.style.width = "25px";
          hoverElement.style.height= "50px";
          hoverElement.style.borderRadius = "0%";
        } else if (currentObject === "circle") {
          hoverElement.style.width = "50px";
          hoverElement.style.height= "50px";
          hoverElement.style.borderRadius = "50%";
        } else if (currentObject === "sign") {
          hoverElement.style.width = "50px";
          hoverElement.style.height= "50px";
          hoverElement.style.borderRadius = "0%";
        }
        hoverElement.style.transform = `rotate(${rotation}deg)`;
      }
    </script>
  </body>
</html>
